/*
 * Since: April 2022
 * Author: gvenzl
 * Name: SimpleOAuth1.java
 * Description: A simple OAuth 1 client.
 *
 * Copyright 2022 Gerald Venzl
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

package com.gvenzl.oauth;

import com.gvenzl.oauth.log.LogLevel;
import com.gvenzl.oauth.log.Logger;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.*;

public class SimpleOAuth1 {

    private final static String SIGNATURE_METHOD = "HMAC-SHA1";
    private final static String VERSION = "1.0";

    private LogLevel logLevel;

    private final String consumerKey;
    private final String consumerKeySecret;
    private final String accessToken;
    private final String accessTokenSecret;

    /**
     * Create a new SimpleOAuth1 object.
     * @param consumerKey the consumer/client key.
     * @param consumerKeySecret the consumer/client key secret.
     * @param accessToken the access token.
     * @param accessTokenSecret the access token secret.
     */
    public SimpleOAuth1 (
            String consumerKey,
            String consumerKeySecret,
            String accessToken,
            String accessTokenSecret) {

        this.consumerKey = consumerKey;
        this.consumerKeySecret = consumerKeySecret;
        this.accessToken = accessToken;
        this.accessTokenSecret = accessTokenSecret;
        this.logLevel = LogLevel.OFF;
    }

    /**
     * Percent encodes a string in UTF-8 character set.
     * @param str the string to encode.
     * @return the encoded string.
     */
    private String encode(String str) {
        Logger.info("Encoding string");
        Logger.debug(String.format("Original string: %s", str));
        String encodedString =  URLEncoder.encode(str, StandardCharsets.UTF_8);
        Logger.debug(String.format("Encoded string: %s", encodedString));
        return encodedString;
    }

    /**
     * Extracts the base URL without parameters.
     * @param url the URL to extract the base URL from.
     * @return the base URL without any parameters.
     */
    private String extractBaseURL (String url) {

        Logger.info("Extracting base URL.");
        Logger.debug(String.format("Original URL: %s", url));

        String baseURL = "";
        if (url.contains("?")) {
            baseURL = url.substring(0, url.indexOf("?"));
        }
        else {
            baseURL = url;
        }

        Logger.debug(String.format("OAuth base URL: %s", baseURL));

        return baseURL;
    }

    /**
     * Extracts the parameter part of a URL.
     * <br/><br/>
     * For example, "https://api.example.com?id=1234" will return "id=1234"
     * @param url the URL to extract the parameters from.
     * @return the parameters part from the url or an empty string if the URL didn't contain any.
     */
    private String extractParamsFromURL (String url) {

        Logger.info("Extracting parameters from URL.");
        Logger.debug(String.format("Original URL: %s", url));

        String params = "";
        if (url.contains("?")) {
            params = url.substring(url.indexOf("?")+1);
        }

        Logger.debug(String.format("Parameters from URL: %s", params));

        return params;
    }

    /**
     * Retrieve a Nonce.
     * <br/><br/>
     * A nonce is a random string, uniquely generated by the client to allow
     * the server to verify that a request has never been made before and
     * helps prevent replay attacks when requests are made over a non-secure
     * channel.  The nonce value MUST be unique across all requests with the
     * same timestamp, client credentials, and token combinations.
     * <br/><br/>
     * To avoid the need to retain an infinite number of nonce values for
     * future checks, servers MAY choose to restrict the time period after
     * which a request with an old timestamp is rejected.  Note that this
     * restriction implies a level of synchronization between the client's
     * and server's clocks.  Servers applying such a restriction MAY provide
     * a way for the client to sync with the server's clock; alternatively,
     * both systems could synchronize with a trusted time service.  Details
     * of clock synchronization strategies are beyond the scope of this
     * specification.
     * @return the nonce
     */
    private String generateNonce() {

        String hash;
        // Generate random bytes for nonce input
        byte[] bytes = new byte[18];
        new Random().nextBytes(bytes);
        // Create digest based on random characters and current timestamp
        String digest = new String(bytes, StandardCharsets.UTF_8) + System.currentTimeMillis()/1000;

        try {
            MessageDigest messageDigest = MessageDigest.getInstance("SHA-1");
            // Hash the digest
            messageDigest.update(digest.getBytes(StandardCharsets.UTF_8));
            // Get Base64 encoded hash string
            hash = new String(Base64.getEncoder().encode(messageDigest.digest()));
        }
        catch (NoSuchAlgorithmException e) {
            // If no SHA algorithm is available, use Base64 encoding of random string+timestamp combination
            hash = new String(Base64.getEncoder().encode(digest.getBytes(StandardCharsets.UTF_8)));
        }

        // Return the first 28 characters (SHA-1 output usually) for nonce
        String nonce = hash.substring(0,28);
        Logger.debug(String.format("Nonce: %s", nonce));

        return nonce;
    }

    /**
     * Returns OAuth headers as a String.
     * <br/><br/>
     * To build the header string, imagine writing to a string named OHS.
     * <br/><br/>
     * 1) Append the string "OAuth " (including the space at the end) to OHS.
     * 2) For each key/value pair of the OAuth parameters:
     *    a) Percent encode the key and append it to OHS.
     *    b) Append the equal character '=' to OHS.
     *    c) Append a double quote '"' to OHS.
     *    d) Percent encode the value and append it to OHS.
     *    e) Append a double quote '"' to OHS.
     *    f) Before the next remaining key/value pair, append a comma ',' and a space ' ' to OHS.
     * <br/><br/>
     * Particular attention needs to be paid to Percent encoding of the values when building this string.
     * For example, the oauth_signature value of tnnArxj06cWHq44gCs1OSKk/jLY= must be encoded as tnnArxj06cWHq44gCs1OSKk%2FjLY%3D.
     * <br/><br/>
     * Performing these steps on the parameters should produce the following result:
     * <br/><br/>
     * OAuth oauth_consumer_key="xvz1evFS4wEEPTGEFPHBog", oauth_nonce="kYjzVBB8Y0ZFabxSWbWovY3uYSQ2pTgmZeNu2VS4cg", oauth_signature="tnnArxj06cWHq44gCs1OSKk%2FjLY%3D", oauth_signature_method="HMAC-SHA1", oauth_timestamp="1318622958", oauth_token="370773112-GmHxMAgYyLbNEtIKZeRNFsMKPR9EyMZeS9weJAEb", oauth_version="1.0"
     *
     * @return the OAuth headers as string
     */
    private String generateOAuthHeader(TreeMap<String, String> params) {

        Logger.info("Generating OAuth header.");
        var builder = new StringBuilder("OAuth ");

        // Append each parameter key and value fully encoded
        params.forEach((String key, String value) ->
                builder.append(encode(key)).append("=\"").append(encode(value)).append("\", "));

        String header = builder.toString();
        // Remove trailing ", " from return string
        header = header.substring(0,header.length()-2);

        Logger.debug(String.format("Header; %s", header));
        return header;
    }

    /**
     * Generates the signature.
     * <br/><br/>
     * The base string is a concatenation of the HTTP method used, the base URL without any query string or hash
     * parameter and the OAuth header string.
     * <br/><br/>
     * The three values must be joined to make a single string, from which the signature will be generated.
     * This is called the signature base string by the OAuth specification.
     * <br/><br/>
     * The OAuth header values need to be encoded into a single string, which will be used later on for the base string.
     * The process to build the OAuth parameter string is very specific:
     * <br/><br/>
     * 1) Percent encode every key and value that will be signed.
     * 2) Sort the list of parameters alphabetically [1] by encoded key [2].
     * 3) For each key/value pair:
     *    a) Append the encoded key to the output string.
     *    b) Append the '=' character to the output string.
     *    c) Append the encoded value to the output string.
     *    d) If there are more key/value pairs remaining, append a '&' character to the output string.
     * <br/><br/>
     * [1] The OAuth spec says to sort lexicographically, which is the default alphabetical sort for many libraries.
     * <br/><br/>
     * [2] In the case of two parameters with the same encoded key, the OAuth spec says to continue sorting based on value.
     * <br/><br/>
     * To create the base string, perform the following steps:
     * <br/><br/>
     * 1) Convert the HTTP Method to uppercase and set the output string equal to this value.
     * 2) Append the '&' character to the output string.
     * 3) Percent encode the URL and append it to the output string.
     * 4) Append the '&' character to the output string.
     * 5) Percent encode the parameter string and append it to the output string.
     * <br/><br/>
     * This will produce the following signature base string:
     * <br/><br/>
     * POST&https%3A%2F%2Fapi.twitter.com%2F1.1%2Fstatuses%2Fupdate.json&include_entities%3Dtrue%26oauth_consumer_key%3Dxvz1evFS4wEEPTGEFPHBog%26oauth_nonce%3DkYjzVBB8Y0ZFabxSWbWovY3uYSQ2pTgmZeNu2VS4cg%26oauth_signature_method%3DHMAC-SHA1%26oauth_timestamp%3D1318622958%26oauth_token%3D370773112-GmHxMAgYyLbNEtIKZeRNFsMKPR9EyMZeS9weJAEb%26oauth_version%3D1.0%26status%3DHello%2520Ladies%2520%252B%2520Gentlemen%252C%2520a%2520signed%2520OAuth%2520request%2521
     * <br/><br/>
     * Make sure to percent encode the parameter string.
     * The signature base string should contain exactly 2 ampersand '&' characters.
     * The percent '%' characters in the parameter string should be encoded as %26 in the signature base string.
     * <br/><br/>
     * The signing key is created out of the consumer secret and access token secret.
     * It is very important to keep these values private.
     * If you feel that your values have been compromised, regenerate your tokens.
     * <br/><br/>
     * Both of these values, the consumer secret and access token secret, need to be combined to form a signing key,
     * which will be used to generate the signature. The signing key is simply the percent encoded consumer secret,
     * followed by an ampersand character '&', followed by the percent encoded token secret:
     * <br/><br/>
     * Note that there are some flows, such as when obtaining a request token, where the token secret is not yet known.
     * In this case, the signing key should consist of the percent encoded consumer secret followed by an ampersand character ‘&’.
     *
     * @param method the HTTP method
     * @param url the base URL
     * @return the generated signature
     */
    private String generateSignature(String method, String url, TreeMap<String, String> params) {

        var builder = new StringBuilder();
        // OAuth parameter string (Percent encoded)
        params.forEach((String key, String value) -> {
            // This results in 'key=value&'
            builder.append(String.format("%s=%s&", encode(key), encode(value)));
        });

        String oauthParameterString = builder.toString();
        // Remove trailing '&'
        oauthParameterString = oauthParameterString.substring(0, oauthParameterString.length()-1);
        Logger.debug(String.format("OAuth parameter string: %s", oauthParameterString));

        // Create base string for signage
        String baseString = method.toUpperCase() + "&" + encode(url) + "&" + encode(oauthParameterString);
        Logger.debug(String.format("OAuth base string: %s", baseString));

        // Create signing key
        String signingKey = encode(consumerKeySecret) + "&" + encode(accessTokenSecret);

        // Generate the signature
        try {
            Mac mac = Mac.getInstance("HmacSHA1");
            mac.init(new SecretKeySpec(signingKey.getBytes(StandardCharsets.UTF_8), "HmacSHA1"));
            String signature = Base64.getEncoder().encodeToString(mac.doFinal(baseString.getBytes(StandardCharsets.UTF_8)));
            Logger.debug(String.format("OAuth signature: %s", signature));
            return signature;
        }
        catch (NoSuchAlgorithmException | InvalidKeyException e) {
            System.err.println("Cannot create HMAC-SHA1 encrypted signature.");
            e.printStackTrace(System.err);
            return "";
        }
    }

    /**
     * Returns the OAuth header for the request.
     * @param method the HTTP method.
     * @param url the HTTP url the call is made to.
     * @param oAuthOnly whether only the OAuth parameters should be retrieved.
     * @return the OAuth header to add to the request.
     */
    public String getOAuthHeader (String method, String url, boolean oAuthOnly) {
        return getOAuthHeader(method, url, "", oAuthOnly);
    }

    /**
     * Returns the OAuth header for the request.
     * @param method the HTTP method.
     * @param url the HTTP url the call is made to.
     * @return the OAuth header to add to the request.
     */
    public String getOAuthHeader (String method, String url) {
        return getOAuthHeader(method, url, "", false);
    }

    /**
     * Returns the OAuth header for the request.
     * @param method the HTTP method.
     * @param url the HTTP url the call is made to.
     * @param bodyParams the parameters of the body for POST requests.
     * @return the OAuth header to add to the request.
     */
    public String getOAuthHeader (String method, String url, String bodyParams) {
        return getOAuthHeader(method, url, bodyParams, false);
    }

        /**
         * Returns the OAuth header for the request.
         * @param method the HTTP method.
         * @param url the HTTP url the call is made to.
         * @param bodyParams the parameters of the body for POST requests.
         * @param oAuthOnly whether only the OAuth parameters should be retrieved.
         * @return the OAuth header to add to the request.
         */
    public String getOAuthHeader (String method, String url, String bodyParams, boolean oAuthOnly) {

        Logger.info("Retrieving OAuth header: %s");
        TreeMap<String, String> params = new TreeMap<>();

        String urlParameters = extractParamsFromURL(url);

        // Add URL parameters to map
        if (!urlParameters.isEmpty()) {
            for (String parameter : urlParameters.split("&")) {
                String[] kv = parameter.split("=");
                params.put(kv[0], kv[1]);
            }
        }

        // Add body parameters to map
        if (!bodyParams.isEmpty()) {
            for (String parameter : bodyParams.split("&")) {
                String[] kv = parameter.split("=");
                params.put(kv[0], kv[1]);
            }
        }

        // Add OAuth parameters
        params.put(OAuthParams.CONSUMER_KEY, consumerKey);
        params.put(OAuthParams.NONCE, generateNonce());
        params.put(OAuthParams.SIGNATURE_METHOD, SIGNATURE_METHOD);
        params.put(OAuthParams.TIMESTAMP, getTimestamp());
        params.put(OAuthParams.TOKEN, accessToken);
        params.put(OAuthParams.VERSION, VERSION);

        // Add signature
        params.put(OAuthParams.SIGNATURE, generateSignature(method, extractBaseURL(url), params));

        // Remove all non-oauth parameters before returning the header
        if (oAuthOnly) {
            params.entrySet().removeIf(entry -> !entry.getKey().startsWith("oauth_"));
        }

        // Generate OAuth header string
        String header = generateOAuthHeader(params);
        Logger.debug(String.format("OAuth header: %s", header));

        return header;
    }

    /**
     * Get the current timestamp as UNIX epoch string.
     * <br/><br/>
     * The timestamp value MUST be a positive integer.  Unless otherwise
     * specified by the server's documentation, the timestamp is expressed
     * in the number of seconds since January 1, 1970 00:00:00 GMT.
     *
     * @return the timestamp (in seconds from UNIX epoch)
     */
    private String getTimestamp() {
        // Timestamp has to be in seconds, divide by 1000 to cut millisecond portion off
        // Use long data type to ensure no float is passed on to String.valueOf
        Logger.info("Generating timestamp.");
        long tms = System.currentTimeMillis()/1000;
        String timestamp = String.valueOf(tms);
        Logger.debug(String.format("Timestamp: %s", timestamp));
        return timestamp;
    }
}
